# -*- coding: utf-8 -*-
"""Text_exp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1omUDRigcVTupnLuc9W-gKcF-1bPzqZV1
"""

!pip install transformers
!pip install bertviz
!pip install umap-learn
!pip install accelerate
!pip install datasets
!pip install nltk
!pip install wordcloud

# Commented out IPython magic to ensure Python compatibility.
import cv2
import pandas as pd
import datasets
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
import os
from PIL import Image, ImageFile
import numba
import plotly.express as px
import plotly.graph_objects as go
from tqdm import tqdm
import re

from transformers import pipeline
from datasets import load_dataset


# %matplotlib inline

"""##Датасеты"""

df_text_test = pd.read_csv('df_text_test-2.csv')

"""
    Dataset for ViT с фильтрацией лэйбла content
"""

ds = load_dataset("tukey/human_face_emotions_roboflow")
ds = ds.filter(lambda example, indice: example['qa'][0]["answer"] != "content", with_indices=True)

ds_split_train_test = ds["train"].train_test_split(test_size=0.15)
train_ds, eval_ds = ds_split_train_test["train"], ds_split_train_test["test"]

ds_split_train_test = train_ds.train_test_split(test_size=0.15)
train_ds, test_ds = ds_split_train_test["train"], ds_split_train_test["test"]

test_ds

def ClassesIndNameConnection():
    """
    Словари для перехода от имени лэйбла к его номеру и наоборот  Distilbert

    return:  class_to_name, name_to_class
    """

    unique_values = df_text_test['label'].unique()
    unique_values_ = df_text_test['label_name'].unique()

    class_to_name = dict(zip(unique_values, unique_values_))

    name_to_class = {}
    for key in class_to_name:
        name_to_class[class_to_name[key]] = key

    return class_to_name, name_to_class

class_to_name, name_to_class = ClassesIndNameConnection()

Distilbert = pipeline("text-classification", model="VK26/disilbert-finetuned-emotion2")

def DistilbertInference(prompt):
        """
        Функция принимает промпт и возращает предсказание затюниного t

        return: label_name, label, best_logit
        """

        preds = Distilbert(prompt)
        preds = sorted(preds, key=lambda item: item["score"], reverse=True)
        class_number = int(preds[0]["label"][-1])
        return class_to_name[class_number], class_number,  preds[0]['score']

"""
    Словари для перехода от имени лэйбла к его номеру и наоборот ViT
"""

tok_to_ind = {'sad': 0,
 'anger': 1,
 'neutral': 2,
 'fear': 3,
 'content': 4,
 'happy': 5,
 'disgust': 6,
 'surprise': 7}

ind_to_tok = {}
for key in tok_to_ind:
    ind_to_tok[tok_to_ind[key]] = key

ViT = pipeline("image-classification", model="VK26/ViT-finetuned-emotion")

def ViTInference(img):
        """
        Функция принимает промпт (картинку) и возращает предсказание затюниного ViT

        return: label_name, label, best_logit
        """
        preds = ViT(img)
        class_ = preds[0]["label"]
        return class_, tok_to_ind[class_],  preds[0]['score']

def CompareInferenceTrue():
    """ Сопоставляет предсказаное значение лэйбла с действительным
        Иллюстрация в виде тепловой карты.

        return: heat_map
    """

    heat_map = np.zeros((7, 7))
    for ind, row in tqdm(df_text_test.iterrows(), ncols=80, ascii=True, desc='Total'):
        prediction = DistilbertInference(row["text"])[1]
        true = row["label"]

        heat_map[prediction][true] += 1

    fig1 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=heat_map,
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(class_to_name.values()),
                   y=list(class_to_name.values()),
                   hoverongaps = False))

    fig2 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=np.round(heat_map / heat_map.sum(axis=0), decimals=2),
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(class_to_name.values()),
                   y=list(class_to_name.values()),
                   hoverongaps = False))
    fig1.show()
    fig2.show()

    return heat_map
    
    
### Figure 1

a = CompareInferenceTrue()

from wordcloud import WordCloud
import matplotlib.pyplot as plt
import nltk
from nltk import word_tokenize, Text
from nltk.probability import FreqDist
from nltk.corpus import stopwords

nltk.download('stopwords')
nltk.download('punkt_tab')

def MostPopularWords(dataset=True):
    """
        dataset=True - по исходному датасету
        dataset=False - по предсказаниям модели

        Функция возвращает словарь, где
        по лэйблу можно получить вложеный словарь с:
        "freq" - список пар  ( слово - частота )
        "text" - текст, очищенный от стопслов для генерации облаков слов
    """
    cnt = {}
    for ind, row in tqdm(df_text_test.iterrows(), ncols=80, ascii=True, desc='Total'):
        text = row["text"]
        label = row["label"] if dataset else DistilbertInference(row["text"])[1]

        if not label in list(cnt.keys()):
            cnt[label] = []

        text = re.sub(r'[^\w\s]', '', text).strip().lower()
        text = text.split()
        cnt[label] += text

    _stopwords = stopwords.words("english")
    for label in cnt:
        _string = " ".join(cnt[label])
        text_tokens = word_tokenize(_string)
        text_tokens = [token.strip() for token in text_tokens if token not in _stopwords]
        cnt[label] = {}
        cnt[label]["text"] = nltk.Text(text_tokens)
        cnt[label]["freq"] = FreqDist(cnt[label]["text"])

    return cnt



def DrowFreqHisto(cnt):
    """
        Рисует топ 7 самых частых слов для каждого лэйбла
    """
    counter = 7
    fig, axs = plt.subplots(3, 3, figsize=(15, 15))
    points = {"0" : {0 : 0}, "1" : {0 : 1}, "2" : {1 : 0}, "3" : {1 : 1}, "4" : {1 : 2}, "5" : {2 : 1}, "6" : {2 : 2}}
    for i in range(7):
        words_freqs = cnt[i]["freq"]
        words_freqs = sorted(words_freqs.items(), key=lambda item: item[1], reverse=True)
        words, freqs = zip(*(words_freqs[:counter]))
        axs[list(points[str(i)].keys())[0], list(points[str(i)].values())[0]].set_title(class_to_name[i])
        axs[list(points[str(i)].keys())[0], list(points[str(i)].values())[0]].barh(words, freqs)


### Figure 7

def DrowWordCloud(cnt):
    """
        Рисует облака слов  для каждого лэйбла
    """
    counter = 7
    fig, axs = plt.subplots(3, 3, figsize=(15, 15))
    points = {"0" : {0 : 0}, "1" : {0 : 1}, "2" : {1 : 0}, "3" : {1 : 1}, "4" : {1 : 2}, "5" : {2 : 1}, "6" : {2 : 2}}
    for i in range(7):
        text = cnt[i]["text"]
        text_raw = " ".join(text)
        wordcloud = WordCloud(width=1600, height=800).generate(text_raw)
        axs[list(points[str(i)].keys())[0], list(points[str(i)].values())[0]].set_title(class_to_name[i])
        axs[list(points[str(i)].keys())[0], list(points[str(i)].values())[0]].imshow(wordcloud)

count_words_by_categories = MostPopularWords(dataset=True)

DrowFreqHisto(count_words_by_categories)

### Figure 3

DrowWordCloud(count_words_by_categories)

### Figure 4

count_words_by_categories_inf = MostPopularWords(dataset=False)

DrowFreqHisto(count_words_by_categories_inf)

### Figure 8

DrowWordCloud(count_words_by_categories_inf)

### Figure 9

def FromBoxModelInference(prompt):
        """
        Функция принимает промпт и возращает предсказание затюниного Distilbert
        из промпта удаленяются супер частотные слова

        return: label_name, label, best_logit
        """
        prompt = prompt.split()
        for i in range(len(prompt), -1):
            if prompt[i] in ["feel", "feeling", "en", "de", "im", "een"]:
                prompt.pop(i)

        prompt = "".join(prompt)
        preds = Distilbert(prompt)
        preds = sorted(preds, key=lambda item: item["score"], reverse=True)

        class_number = int(preds[0]["label"][-1])
        return class_to_name[class_number], class_number,  preds[0]['score']


def InferenceFails():
    """ Сопоставляет предсказаное значение лэйбла с действительным
        Со скорректированным промптом для Distilbert

        Иллюстрация в виде тепловой карты.

        return: heat_map
    """
    heat_map = np.zeros((7, 7))
    for ind, row in tqdm(df_text_test.iterrows(), ncols=80, ascii=True, desc='Total'):
        prediction = FromBoxModelInference(row["text"])[1]
        true = row["label"]

        heat_map[prediction][true] += 1

    fig1 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=heat_map,
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(class_to_name.values()),
                   y=list(class_to_name.values()),
                   hoverongaps = False))

    fig2 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=np.round(heat_map / heat_map.sum(axis=0), decimals=2),
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(class_to_name.values()),
                   y=list(class_to_name.values()),
                   hoverongaps = False))
    fig1.show()
    fig2.show()

    return heat_map

### Figure 10

a = InferenceFails()

def InferenceFromLenght():
    """
        Зависимость качества предсказания от длины промпта
    """
    len_ = []
    true_or_false = []
    for ind, row in tqdm(df_text_test.iterrows(), ncols=80, ascii=True, desc='Total'):
        len_.append(len(row["text"].split()))
        prediction = DistilbertInference(row["text"])[1]
        true = row["label"]
        if prediction == true:
            true_or_false.append(1)
        else:
            true_or_false.append(0)

    len_and_tags = zip(len_, true_or_false)
    len_and_tags = sorted(len_and_tags, key=lambda x: x[0])


    x_len, y_accur = [10*i for i in range(13)], [0]*12
    curr = 0
    count = 0
    for Length, flag in len_and_tags:
        if Length < x_len[curr]:
            y_accur[curr] += flag
            count += 1
        else:
            if count > 0:
                y_accur[curr] = y_accur[curr] / count
            count = 0
            curr += 1
            y_accur[curr] += flag
            count += 1


    return x_len, y_accur

x, y = InferenceFromLenght()

plt.bar(x[:12], y)
plt.title("accuracy vs length")

### Figure 11

print(x[:11], y[:11])

from tqdm import trange

def CompareInferenceTrueViT():
    """ Сопоставляет предсказаное значение ViT лэйбла с действительным
        Иллюстрация в виде тепловой карты.

        return: heat_map
    """
    mmp = {'sad': 0,
            'anger': 1,
            'neutral': 2,
            'fear': 3,
            'happy': 4,
            'disgust': 5,
            'surprise': 6}

    heat_map = np.zeros((7, 7))
    for i in trange(1053):
        prediction = ViTInference(test_ds[i]["image"])[1]
        true = tok_to_ind[test_ds[i]['qa'][0]["answer"]]
        if prediction==4 or true==4:
            continue
        if prediction>4:
            prediction -= 1
        if true>4:
            true -= 1
        heat_map[prediction][true] += 1

    fig1 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=heat_map,
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(mmp.keys()),
                   y=list(mmp.keys()),
                   hoverongaps = False))

    fig2 = go.Figure(data=go.Heatmap(
                   z=heat_map / heat_map.sum(axis=0),
                   text=np.round(heat_map / heat_map.sum(axis=0), decimals=2),
                   texttemplate="%{text}",
                   textfont={"size":20},
                   x=list(mmp.keys()),
                   y=list(mmp.keys()),
                   hoverongaps = False))
    fig1.show()
    fig2.show()

    return heat_map

a = CompareInferenceTrueViT()

### Figure 12
